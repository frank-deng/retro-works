DEFINT A-Z
TYPE REGSTYPE
  AX AS INTEGER
  BX AS INTEGER
  CX AS INTEGER
  DX AS INTEGER
  BP AS INTEGER
  SI AS INTEGER
  DI AS INTEGER
  DS AS INTEGER
  ES AS INTEGER
  FLAGS AS INTEGER
END TYPE
DECLARE SUB INTX(N AS INTEGER,REGS AS REGSTYPE)
DECLARE FUNCTION n$ (n%)
DECLARE SUB TX (s AS STRING)

DIM SHARED ASMINTX(37),ASMDRAW(44)
TYPE FontDataT
    CH0 AS STRING * 1
    CH1 AS STRING * 1
    FONT AS INTEGER
    W AS INTEGER
    H AS INTEGER
    TOP AS INTEGER
    BOTTOM AS INTEGER
    ATTR AS INTEGER
    BUFLEN AS INTEGER
END TYPE
TYPE DrawBitmapT
    W AS INTEGER
    H AS INTEGER
    X AS INTEGER
    Y AS INTEGER
    C AS STRING*1
END TYPE
DIM SHARED BITMAP(8194) AS INTEGER
COMMON SHARED REGS AS REGSTYPE

CALL INITENV
OPEN "LPT3" FOR OUTPUT AS #1
TX ("M10CU1,0CO8KB1,0CL0")

I = 0
FOR y = 0 TO 15
  FOR x = 0 TO 15
    TX ("CO" + n$(I) + "B" + n$(x * 40) + "," + n$(y * 30) + "," + n$(x * 40 + 40) + "," + n$(y * 30 + 30))
    I = I + 1
  NEXT x
NEXT y
WHILE INPUT$(1) = "": WEND

TX ("CL0CO0B0,0,640,480CO7")
I = 0
FOR y = 0 TO 8
  FOR x = 0 TO 3
    TX ("{(7@52,52=" + n$(I) + "-" + n$(x * 160) + "|" + n$(y * 53) + "}")
    TX ("{×ÖÌå" + n$(I) + "}")
    I = I + 1
  NEXT x
NEXT y
WHILE INPUT$(1) = "": WEND

TX ("CL0CO0B0,0,640,480CO7")
FOR FONT=1 TO 10
CALL DrawStr("ABCDEFGHIJKLMNOPQRSTUVWXYZ",0,(FONT-1)*48,FONT,12,24,7)
CALL DrawStr("1234567890 !@#%^&*(),.?+=~`",0,(FONT-1)*48+24,FONT,12,24,7)
NEXT FONT
WHILE INPUT$(1) = "": WEND

TX ("KB1,1M3CU1,1")
CLOSE
END

FUNCTION n$ (A AS INTEGER)
n$ = LTRIM$(RTRIM$(STR$(A)))
END FUNCTION

SUB TX (s AS STRING)
PRINT #1, CHR$(14); "["; s; "]";
END SUB

SUB DrawStr(STR AS STRING, X1 AS INTEGER, Y1 AS INTEGER, FONT AS INTEGER, W0 AS INTEGER, H AS INTEGER, C AS INTEGER)
    I=0: L=LEN(STR): WA=W0: XA=X1
    WHILE I<L
        CH$=MID$(STR,I+1,1)
        IF ASC(CH$)>=&H80 THEN
            I=I+1: CH$=CH$+MID$(STR,I+1,1)
        END IF
        WA=W0: CALL GetChar(CH$,FONT,WA,H,1)
        CALL DrawChar(WA,H,XA,Y1,C)
        XA=XA+WA: I=I+1
    WEND
END SUB

SUB GetChar(STR AS STRING,FONT AS INTEGER,W AS INTEGER,H AS INTEGER,ATTR AS INTEGER)
    STATIC Param AS FontDataT
    IF ASC(MID$(STR,1,1)) < &H80 THEN
        Param.CH0=STR: Param.CH1=CHR$(0)
        Param.W=W
    ELSE
        Param.CH0=MID$(STR,2,1): Param.CH1=MID$(STR,1,1)
        Param.W=W*2
    END IF
    Param.FONT=FONT: Param.H=H
    Param.TOP=0: Param.BOTTOM=H-1
    Param.ATTR=1: Param.BUFLEN=16384
    REGS.DS=VARSEG(Param): REGS.ES=VARSEG(BITMAP(0))
    REGS.SI=VARPTR(Param): REGS.DI=VARPTR(BITMAP(0))
    CALL INTX(&H7E,REGS)
    W=Param.W
END SUB

SUB DrawChar(W AS INTEGER, H AS INTEGER, X AS INTEGER, Y AS INTEGER, C AS INTEGER)
    STATIC Param AS DrawBitmapT
    Param.W=W: Param.H=H: Param.X=X: Param.Y=Y: Param.C=CHR$(C)
    DS=VARSEG(Param): ES=VARSEG(BITMAP(0))
    SI=VARPTR(Param): DI=VARPTR(BITMAP(0))
    DEF SEG=VARSEG(SI): SI0=PEEK(VARPTR(SI)): SI1=PEEK(VARPTR(SI)+1)
    DEF SEG=VARSEG(DI): DI0=PEEK(VARPTR(DI)): DI1=PEEK(VARPTR(DI)+1)
    DEF SEG=VARSEG(DS): DS0=PEEK(VARPTR(DS)): DS1=PEEK(VARPTR(DS)+1)
    DEF SEG=VARSEG(ES): ES0=PEEK(VARPTR(ES)): ES1=PEEK(VARPTR(ES)+1)
    DEF SEG=VARSEG(ASMDRAW(0)): OFFSET=VARPTR(ASMDRAW(0))
    POKE OFFSET+6, SI0: POKE OFFSET+7, SI1
    POKE OFFSET+9, DS0: POKE OFFSET+10, DS1
    POKE OFFSET+14, DI0: POKE OFFSET+15, DI1
    POKE OFFSET+17, ES0: POKE OFFSET+18, ES1
    CALL ABSOLUTE(OFFSET)
    DEF SEG
END SUB

DATA &H56,&HBE,&H0,&H0,&H50,&HB8,&H0,&H0,&H53,&H51,&H52,&H55,&H57,&H1E,&H6
DATA &H8E,&HD8,&HB9,&H9,&H0,&HFF,&H34,&H46,&H46,&HE2,&HFA,&H7,&H1F,&H5F,&H5E
DATA &H5D,&H5A,&H59,&H5B,&H58,&HCD,&H0,&H9C,&H6,&H1E,&H57,&H56,&H55,&H52,&H51
DATA &H53,&H50,&HB8,&H0,&H0,&H8E,&HD8,&HB9,&HA,&H0,&HBE,&H0,&H0,&H8F,&H4,&H46
DATA &H46,&HE2,&HFA,&H7,&H1F,&H5F,&H5D,&H5A,&H59,&H5B,&H58,&H5E,&HCB
DATA &H1E,&H6,&H56,&H57,&H50,&HBE,&H0,&H0,&HB8,&H0,&H0,&H8E,&HD8,&HBF,&H0,&H0,&HB8,&H0,&H0,&H8E,&HC0,&H53,&H51,&H52,&H8B,&H44,&H2,&H2E,&HA3,&H56,&H1,&H8B
DATA &H54,&H6,&H8A,&H44,&H8,&H8B,&H4C,&H4,&H8B,&H1C,&HB4,&H80,&H50,&H26,&H22,&H25,&H74,&H4,&HB4,&HC,&HCD,&H10,&H58,&H4B,&H74,&HB,&H41,&H80,&HFC,&H1,&H75,&H1
DATA &H47,&HD0,&HCC,&HEB,&HE7,&H47,&H42,&H83,&H6C,&H2,&H1,&H75,&HD8,&H5A,&H59,&H5B,&H58,&H5F,&H5E,&H7,&H1F,&HCB,&H0,&H0

SUB INITENV()
  DEF SEG = VARSEG(ASMINTX(0)): P = VARPTR(ASMINTX(0))
  FOR I = 0 TO 73: READ V: POKE P+I,V: NEXT I
  DEF SEG = VARSEG(ASMDRAW(0)): P = VARPTR(ASMDRAW(0))
  FOR I = 0 TO 87: READ V: POKE P+I,V: NEXT I
  DEF SEG
  REGS.AX=&HDB00:CALL INTX(&H2F,REGS)
  IF (REGS.AX AND 255)<>255 OR REGS.BX<>&H5450 THEN
    PRINT "Please run UCDOS first.":END
  END IF
  REGS.AX=&H11:CALL INTX(&H79,REGS)
  IF (REGS.FLAGS AND &H40)=0 THEN
    PRINT "Please run TX.COM first.": END
  END IF
END SUB

SUB INTX (N AS INTEGER, REGS AS REGSTYPE)
  STATIC DS AS INTEGER,SI AS INTEGER,P AS INTEGER
  DS=VARSEG(REGS):SI=VARPTR(REGS)
  ASMINTX(1)=SI:ASMINTX(3)=DS
  ASMINTX(24)=DS:ASMINTX(28)=SI
  DEF SEG=VARSEG(ASMINTX(0)):P=VARPTR(ASMINTX(0))
  POKE P+&H24,N:CALL ABSOLUTE(P):DEF SEG
END SUB

