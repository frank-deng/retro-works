DEFINT A-Z
DIM SHARED BITMASK(8)
TYPE REGSTYPE
  AX AS INTEGER
  BX AS INTEGER
  CX AS INTEGER
  DX AS INTEGER
  BP AS INTEGER
  SI AS INTEGER
  DI AS INTEGER
  DS AS INTEGER
  ES AS INTEGER
  FLAGS AS INTEGER
END TYPE
DIM SHARED ASMINTX(47) AS INTEGER
DECLARE SUB INITASM()
DECLARE SUB INTX(N AS INTEGER,REGS AS REGSTYPE)
TYPE FontDataT
  CH0 AS STRING * 1
  CH1 AS STRING * 1
  FONT AS INTEGER
  W AS INTEGER
  H AS INTEGER
  TOP AS INTEGER
  BOTTOM AS INTEGER
  ATTR AS INTEGER
  BUFLEN AS INTEGER
END TYPE
DIM SHARED BITMAP(8194) AS INTEGER
COMMON SHARED REGS AS REGSTYPE
DECLARE SUB INITENV()

CALL INITENV

REM ZSJS.BAS
SCREEN 2: CALL PreDraw:LOCATE 1, 1, 0:CLS
CALL DrawStr("÷Ó ¬",0,0,3,156,76,0,1)
CALL DrawStr("Ω‘À≥",0,76,3,156,76,0,1)
GET (0,0)-(156*2-1,76*2-1),BITMAP(0)
DATASIZE=((156*2+7)\8)*(76*2)+4
DEF SEG=VARSEG(BITMAP(0)): BSAVE "ZSJS.PIC",0,DATASIZE: DEF SEG
WHILE INPUT$(1) = "": WEND

SCREEN 0: WIDTH 80: LOCATE ,,1: CLS : END

SUB PreDraw()
  REGS.AX=&HFF0B:CALL INTX(&H16,REGS)
END SUB

SUB DrawStr(STR AS STRING, X1 AS INTEGER, Y1 AS INTEGER, FONT AS INTEGER, W0 AS INTEGER, H AS INTEGER, SP0 AS INTEGER, C AS INTEGER)
  I=0: L=LEN(STR): WA=W0: XA=X1
  WHILE I<L
    CH$=MID$(STR,I+1,1)
    IF ASC(CH$)>=&H80 THEN
      I=I+1: CH$=CH$+MID$(STR,I+1,1)
    END IF
    WA=W0: CALL DrawChar(CH$,XA,Y1,FONT,WA,H,C)
    XA=XA+WA+SP0: I=I+1
  WEND
END SUB

SUB DrawChar(STR AS STRING, X0 AS INTEGER, Y0 AS INTEGER, FONT AS INTEGER, W AS INTEGER, H AS INTEGER, C AS INTEGER)
  STATIC Param AS FontDataT
  IF ASC(MID$(STR,1,1)) < &H80 THEN
    Param.CH0=STR: Param.CH1=CHR$(0)
    Param.W=W\2
  ELSE
    Param.CH0=MID$(STR,2,1): Param.CH1=MID$(STR,1,1)
    Param.W=W
  END IF
  Param.FONT=FONT: Param.H=H
  Param.TOP=0: Param.BOTTOM=H-1
  Param.ATTR=1: Param.BUFLEN=16384
  REGS.DS=VARSEG(Param): REGS.ES=VARSEG(BITMAP(0))
  REGS.SI=VARPTR(Param): REGS.DI=VARPTR(BITMAP(0))
  CALL INTX(&H7E,REGS)
  W=Param.W
  DEF SEG=VARSEG(BITMAP(0)): ROWBYTES=(W+7)\8: PX=VARPTR(BITMAP(0)): P=PEEK(PX)
  FOR Y=0 TO (H-1): FOR X=0 TO (W-1)
    IF P AND BITMASK(X AND 7) THEN PSET (X0+X,Y0+Y),C
    IF (X AND 7)=7 OR X=(W-1) THEN PX=PX+1: P=PEEK(PX)
  NEXT X: NEXT Y: DEF SEG
END SUB

SUB INITENV()
  FOR I = 0 TO 7: BITMASK(I) = 2 ^ (7 - I): NEXT I
  CALL INITASM
  REGS.AX=&HDB00:CALL INTX(&H2F,REGS)
  IF (REGS.AX AND 255)<>255 OR REGS.BX<>&H5450 THEN
    PRINT "Please run UCDOS first.":END
  END IF
  REGS.AX=1:CALL INTX(&H79,REGS)
  IF (REGS.FLAGS AND &H40)=0 THEN
    PRINT "Please run RDFNT first.": END
  END IF
END SUB

DATA &H50,&H53,&H51,&H52,&H55,&H56,&H57,&H1E,&H6,&HBE,&H0,&H0,&HB8,&H0,&H0,&H2E,&H89,&H36,&H58,&H1,&H2E,&HA3,&H5A,&H1,&H8E,&HD8,&HB9,&H9,&H0,&HFF,&H34,&H83,&HC6,&H2,&HE2,&HF9,&H7,&H1F,&H5F,&H5E,&H5D,&H5A,&H59,&H5B,&H58,&HCD,&H0,&H9C,&H6,&H1E,&H57,&H56,&H55,&H52,&H51,&H53,&H50,&H2E,&HA1,&H5A,&H1,&H8E,&HD8,&H2E,&H8B,&H36,&H58,&H1,&HB9,&HA,&H0,&H8F,&H4,&H83,&HC6,&H2,&HE2,&HF9,&H7,&H1F,&H5F,&H5E,&H5D,&H5A,&H59,&H5B,&H58,&HCB,&H0,&H0,&H0,&H0,&H0

SUB INITASM
  DEF SEG = VARSEG(ASMINTX(0)): P = VARPTR(ASMINTX(0))
  FOR I = 0 TO 92: READ V: POKE P, V: P = P + 1: NEXT I
  DEF SEG
END SUB

SUB INTX (N AS INTEGER, REGS AS REGSTYPE)
  STATIC DS AS INTEGER,SI AS INTEGER,P AS INTEGER
  DS=VARSEG(REGS):SI=VARPTR(REGS)
  DEF SEG=VARSEG(DS):P=VARPTR(DS):DS0=PEEK(P): DS1=PEEK(P+1)
  DEF SEG=VARSEG(SI):P=VARPTR(SI):SI0=PEEK(P): SI1=PEEK(P+1)
  DEF SEG=VARSEG(ASMINTX(0)): P=VARPTR(ASMINTX(0))
  POKE P+&H2E,N
  POKE P+&HA,SI0:POKE P+&HB,SI1
  POKE P+&HD,DS0:POKE P+&HE,DS1
  CALL ABSOLUTE(P)
  DEF SEG
END SUB

